name: üèóÔ∏è Build and Push Images

on:
  workflow_call:
    inputs:
      apps:
        description: 'Comma-separated list of apps to build (e.g., "nextjs,laravel"). Empty = build nothing.'
        required: false
        type: string

jobs:
  detect-images:
    name: üîç Detect Images to Build
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-images: ${{ steps.set-matrix.outputs.has-images }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0

      - name: üìã Show build context
        run: |
          echo "Commit: $(git rev-parse HEAD)"
          echo "Branch: $(git rev-parse --abbrev-ref HEAD)"

      - name: üîç Detect images and build targets
        id: set-matrix
        shell: bash
        run: |
          set -e

          if [ -z "${{ inputs.apps }}" ]; then
            echo "No apps provided ‚Üí skipping build"
            echo 'matrix={"include":[{"image":"none","target":"none"}]}' >> $GITHUB_OUTPUT
            echo "has-images=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          apps=$(echo "${{ inputs.apps }}" | tr ',' ' ')
          echo "Apps to build: $apps"

          matrix_include=()

          for app in $apps; do
            dockerfile="examples/$app/Dockerfile"

            if [ ! -f "$dockerfile" ]; then
              echo "‚ö†Ô∏è No Dockerfile for $app, skipping"
              continue
            fi

            # Extract named build targets
            targets=$(grep -i '^FROM .* AS ' "$dockerfile" | sed -n 's/.*AS \([^ ]*\).*/\1/p')

            valid_targets=()

            # Filter out builder targets
            for target in $targets; do
              [[ "$target" == *builder* ]] && continue
              valid_targets+=("$target")
            done

            if [ "${#valid_targets[@]}" -eq 0 ]; then
              # No named targets ‚Üí default build
              matrix_include+=("{\"image\":\"$app\",\"target\":\"\"}")
            else
              for target in "${valid_targets[@]}"; do
                matrix_include+=("{\"image\":\"$app\",\"target\":\"$target\"}")
              done
            fi
          done

          if [ "${#matrix_include[@]}" -eq 0 ]; then
            echo "No valid images found"
            echo 'matrix={"include":[{"image":"none","target":"none"}]}' >> $GITHUB_OUTPUT
            echo "has-images=false" >> $GITHUB_OUTPUT
          else
            matrix=$(printf ',%s' "${matrix_include[@]}")
            matrix="[${matrix:1}]"
            echo "matrix={\"include\":$matrix}" >> $GITHUB_OUTPUT
            echo "has-images=true" >> $GITHUB_OUTPUT
            echo "Build matrix: $matrix"
          fi

  build-push:
    name: üèóÔ∏è Build ${{ matrix.image }}${{ matrix.target && format(' ({0})', matrix.target) || '' }}
    needs: detect-images
    if: needs.detect-images.outputs.has-images == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    strategy:
      matrix: ${{ fromJSON(needs.detect-images.outputs.matrix) }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: üîê Login to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Determine version for ${{ matrix.image }}
        id: version
        shell: bash
        run: |
          set -e

          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/images/${{ matrix.image }}"
          TARGET="${{ matrix.target }}"

          if [ "$TARGET" = "production" ]; then
            echo "Production build"

            LATEST_TAG=$(docker manifest inspect ${IMAGE_NAME}:latest 2>/dev/null | \
              jq -r '.manifests[0].annotations."org.opencontainers.image.version"' 2>/dev/null || echo "")

            if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
              LATEST_TAG=$(git tag -l "${{ matrix.image }}/v*" --sort=-v:refname | head -n1 | sed 's|${{ matrix.image }}/||' || echo "")
            fi

            if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
              NEW_VERSION="v0.1.0"
            else
              LAST_TAG_COMMIT=$(git rev-list -n 1 "${{ matrix.image }}/${LATEST_TAG}" 2>/dev/null || echo "")
              COMMITS=$(git log ${LAST_TAG_COMMIT}..HEAD -- examples/${{ matrix.image }}/ | wc -l)

              if [ "$COMMITS" -eq 0 ]; then
                NEW_VERSION="$LATEST_TAG"
              else
                if git log ${LAST_TAG_COMMIT}..HEAD -- examples/${{ matrix.image }}/ | grep -qiE "^(feat|feature)(\(.*\))?!:|BREAKING CHANGE:"; then
                  BUMP="major"
                elif git log ${LAST_TAG_COMMIT}..HEAD -- examples/${{ matrix.image }}/ | grep -qiE "^(feat|feature)(\(.*\))?:"; then
                  BUMP="minor"
                else
                  BUMP="patch"
                fi

                CURRENT="${LATEST_TAG#v}"
                IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

                case "$BUMP" in
                  major) MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0 ;;
                  minor) MINOR=$((MINOR+1)); PATCH=0 ;;
                  patch) PATCH=$((PATCH+1)) ;;
                esac

                NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
              fi
            fi

            echo "VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "TAGS=${IMAGE_NAME}:${NEW_VERSION},${IMAGE_NAME}:production,${IMAGE_NAME}:latest" >> $GITHUB_OUTPUT
          else
            # Default / non-production target
            TAG="${TARGET:-latest}"
            echo "VERSION=$TAG" >> $GITHUB_OUTPUT
            echo "TAGS=${IMAGE_NAME}:${TAG}" >> $GITHUB_OUTPUT
          fi

      - name: üèóÔ∏è Build and push ${{ matrix.image }}${{ matrix.target && format(' ({0})', matrix.target) || '' }}
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: examples/${{ matrix.image }}
          target: ${{ matrix.target }}
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.version.outputs.TAGS }}
          labels: |
            org.opencontainers.image.title=${{ matrix.image }} Demo Application
            org.opencontainers.image.description=${{ matrix.image }} demo application - Production-ready Kubernetes deployment with Helm charts
            org.opencontainers.image.version=${{ steps.version.outputs.VERSION }}
            org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}/tree/main/examples/${{ matrix.image }}
            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/main/examples/${{ matrix.image }}/README.md
            org.opencontainers.image.licenses=MIT
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ‚úÖ Image built and pushed successfully
        run: |
          echo "Image: ${{ matrix.image }}"
          echo "Target: ${{ matrix.target || 'default' }}"
          echo "Version: ${{ steps.version.outputs.VERSION }}"
          echo "Tags: ${{ steps.version.outputs.TAGS }}"
