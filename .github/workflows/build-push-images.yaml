name: üèóÔ∏è Build and Push Images

on:
  workflow_dispatch:
    inputs:
      apps:
        description: 'Comma-separated list of apps to build (e.g., "nextjs,laravel"). Leave empty to build all.'
        required: false
        type: string
      ref:
        description: 'Git ref (branch, tag, or commit SHA) to build from. Defaults to the branch you selected in the UI.'
        required: false
        type: string
  workflow_call:
    inputs:
      apps:
        description: 'Comma-separated list of apps to build (e.g., "nextjs,laravel"). Leave empty to build all.'
        required: false
        type: string
      ref:
        description: 'Git ref (branch, tag, or commit SHA) to build from. Defaults to the calling workflow ref.'
        required: false
        type: string

jobs:
  detect-images:
    name: üîç Detect Images to Build
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-images: ${{ steps.set-matrix.outputs.has-images }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          ref: ${{ inputs.ref || github.ref }}
          fetch-depth: 0

      - name: üìã Show build context
        run: |
          echo "Building from ref: ${{ inputs.ref || github.ref }}"
          echo "Current commit: $(git rev-parse HEAD)"
          echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"

      - name: üîç Detect images and build targets
        id: set-matrix
        run: |
          # Get all app directories in examples/
          if [ -n "${{ inputs.apps }}" ]; then
            # User specified apps
            all_apps=$(echo "${{ inputs.apps }}" | tr ',' ' ')
            echo "Building specified apps: $all_apps"
          else
            # Build all apps
            all_apps=$(find examples -maxdepth 1 -mindepth 1 -type d -exec basename {} \;)
            echo "Building all apps: $all_apps"
          fi

          # Build matrix with image and target combinations
          matrix_include="["
          first=true

          for app in $all_apps; do
            dockerfile="examples/$app/Dockerfile"

            if [ -f "$dockerfile" ]; then
              # Extract all targets from the Dockerfile (exact names)
              targets=$(grep -i "^FROM .* AS " "$dockerfile" | sed -n 's/.*AS \([^ ]*\).*/\1/p' || echo "")

              # Process each target, skipping any with "builder" in the name
              for target in $targets; do
                if [[ "$target" == *builder* ]]; then
                  echo "Skipping builder target: $target"
                  continue
                fi
                [ "$first" = false ] && matrix_include+=","
                matrix_include+="{\"image\":\"$app\",\"target\":\"$target\"}"
                first=false
              done
            else
              echo "Warning: No Dockerfile found for $app, skipping"
            fi
          done

          matrix_include+="]"

          if [ "$matrix_include" = "[]" ]; then
            # Provide a dummy matrix entry to prevent GitHub Actions error
            # The build-push job will be skipped via the if condition
            echo "matrix={\"include\":[{\"image\":\"none\",\"target\":\"none\"}]}" >> $GITHUB_OUTPUT
            echo "has-images=false" >> $GITHUB_OUTPUT
            echo "No images to build - providing dummy matrix"
          else
            echo "matrix={\"include\":$matrix_include}" >> $GITHUB_OUTPUT
            echo "has-images=true" >> $GITHUB_OUTPUT
            echo "Build matrix: {\"include\":$matrix_include}"
          fi

  build-push:
    name: üèóÔ∏è Build ${{ matrix.image }} (${{ matrix.target || 'default' }})
    needs: detect-images
    if: needs.detect-images.outputs.has-images == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    strategy:
      matrix: ${{ fromJSON(needs.detect-images.outputs.matrix) }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          ref: ${{ inputs.ref || github.ref }}
          fetch-depth: 0

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: üîê Login to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Determine version for ${{ matrix.image }}
        id: version
        run: |
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/images/${{ matrix.image }}"
          TARGET="${{ matrix.target }}"

          # Production target gets semantic versioning + 'production' and 'latest' tags
          if [ "$TARGET" = "production" ]; then
            echo "Production build"

            # Try to get the latest version from GHCR
            LATEST_TAG=$(docker manifest inspect ${IMAGE_NAME}:latest 2>/dev/null | \
              jq -r '.manifests[0].annotations."org.opencontainers.image.version"' 2>/dev/null || echo "")

            if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
              # No existing version, check git tags for this app
              LATEST_TAG=$(git tag -l "${{ matrix.image }}/v*" --sort=-v:refname | head -n1 | sed 's|${{ matrix.image }}/||' || echo "")
            fi

            if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
              # No version found, start with v0.1.0
              NEW_VERSION="v0.1.0"
              echo "No existing version found, starting with $NEW_VERSION"
            else
              # Bump version based on commits
              echo "Latest version: $LATEST_TAG"

              # Get commits since last tag for this app
              LAST_TAG_COMMIT=$(git rev-list -n 1 "${{ matrix.image }}/${LATEST_TAG}" 2>/dev/null || echo "")

              if [ -n "$LAST_TAG_COMMIT" ]; then
                COMMITS=$(git log ${LAST_TAG_COMMIT}..HEAD --oneline -- examples/${{ matrix.image }}/ | wc -l)
              else
                COMMITS=$(git log --oneline -- examples/${{ matrix.image }}/ | wc -l)
              fi

              if [ "$COMMITS" -eq 0 ]; then
                # No changes, keep same version
                NEW_VERSION="$LATEST_TAG"
                echo "No changes detected, keeping version $NEW_VERSION"
              else
                # Analyze commits for version bump type
                if git log ${LAST_TAG_COMMIT}..HEAD -- examples/${{ matrix.image }}/ | grep -qiE "^(feat|feature)(\(.*\))?!:|BREAKING CHANGE:"; then
                  # Breaking change -> major bump
                  BUMP_TYPE="major"
                elif git log ${LAST_TAG_COMMIT}..HEAD -- examples/${{ matrix.image }}/ | grep -qiE "^(feat|feature)(\(.*\))?:"; then
                  # New feature -> minor bump
                  BUMP_TYPE="minor"
                else
                  # Bug fix or other -> patch bump
                  BUMP_TYPE="patch"
                fi

                # Parse current version
                CURRENT_VERSION="${LATEST_TAG#v}"
                IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

                # Bump version
                case "$BUMP_TYPE" in
                  major)
                    MAJOR=$((MAJOR + 1))
                    MINOR=0
                    PATCH=0
                    ;;
                  minor)
                    MINOR=$((MINOR + 1))
                    PATCH=0
                    ;;
                  patch)
                    PATCH=$((PATCH + 1))
                    ;;
                esac

                NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
                echo "Bumped version: $LATEST_TAG -> $NEW_VERSION (type: $BUMP_TYPE, commits: $COMMITS)"
              fi
            fi

            echo "VERSION=${NEW_VERSION}" >> $GITHUB_OUTPUT
            echo "TAGS=${IMAGE_NAME}:${NEW_VERSION},${IMAGE_NAME}:production,${IMAGE_NAME}:latest" >> $GITHUB_OUTPUT
            echo "Production build - using version ${NEW_VERSION} with tags: production, latest"
          else
            # All other targets use their exact target name as the tag
            echo "VERSION=${TARGET}" >> $GITHUB_OUTPUT
            echo "TAGS=${IMAGE_NAME}:${TARGET}" >> $GITHUB_OUTPUT
            echo "Build for target '${TARGET}' - using tag '${TARGET}'"
          fi

      - name: üèóÔ∏è Build and push ${{ matrix.image }} (${{ matrix.target || 'default' }})
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: examples/${{ matrix.image }}
          target: ${{ matrix.target }}
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.version.outputs.TAGS }}
          labels: |
            org.opencontainers.image.title=${{ matrix.image }} Demo Application
            org.opencontainers.image.description=${{ matrix.image }} demo application - Production-ready Kubernetes deployment with Helm charts
            org.opencontainers.image.version=${{ steps.version.outputs.VERSION }}
            org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}/tree/main/examples/${{ matrix.image }}
            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/main/examples/${{ matrix.image }}/README.md
            org.opencontainers.image.licenses=MIT
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ‚úÖ Image built and pushed successfully
        run: |
          echo "Successfully built and pushed ${{ matrix.image }} image"
          echo "Target: ${{ matrix.target || 'default' }}"
          echo "Version: ${{ steps.version.outputs.VERSION }}"
          echo "Tags: ${{ steps.version.outputs.TAGS }}"
