name: üèóÔ∏è Build and Push Images

on:
  workflow_dispatch:
    inputs:
      apps:
        description: 'Comma-separated list of apps to build (e.g., "nextjs,laravel"). Leave empty to build all.'
        required: false
        type: string
  workflow_call:
    inputs:
      apps:
        description: 'Comma-separated list of apps to build (e.g., "nextjs,laravel"). Leave empty to build all.'
        required: false
        type: string

jobs:
  detect-images:
    name: üîç Detect Images to Build
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0

      - name: üîç Detect images and build targets
        id: set-matrix
        run: |
          # Get all app directories in examples/
          if [ -n "${{ inputs.apps }}" ]; then
            # User specified apps
            all_apps=$(echo "${{ inputs.apps }}" | tr ',' ' ')
            echo "Building specified apps: $all_apps"
          else
            # Build all apps
            all_apps=$(find examples -maxdepth 1 -mindepth 1 -type d -exec basename {} \;)
            echo "Building all apps: $all_apps"
          fi

          # Build matrix with image and target combinations
          matrix_include="["
          first=true

          for app in $all_apps; do
            dockerfile="examples/$app/Dockerfile"

            if [ -f "$dockerfile" ]; then
              # Check for all possible build targets in Dockerfile
              has_dev_web=$(grep -i "^FROM .* AS development-web" "$dockerfile" || echo "")
              has_prod_web=$(grep -i "^FROM .* AS production-web" "$dockerfile" || echo "")
              has_cli=$(grep -i "^FROM .* AS cli" "$dockerfile" || echo "")

              # Build all variants that exist
              if [ -n "$has_dev_web" ]; then
                [ "$first" = false ] && matrix_include+=","
                matrix_include+="{\"image\":\"$app\",\"target\":\"development-web\"}"
                first=false
              fi
              if [ -n "$has_prod_web" ]; then
                [ "$first" = false ] && matrix_include+=","
                matrix_include+="{\"image\":\"$app\",\"target\":\"production-web\"}"
                first=false
              fi
              if [ -n "$has_cli" ]; then
                [ "$first" = false ] && matrix_include+=","
                matrix_include+="{\"image\":\"$app\",\"target\":\"cli\"}"
                first=false
              fi
            else
              echo "Warning: No Dockerfile found for $app, skipping"
            fi
          done

          matrix_include+="]"

          if [ "$matrix_include" = "[]" ]; then
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "No images to build"
          else
            echo "matrix={\"include\":$matrix_include}" >> $GITHUB_OUTPUT
            echo "Build matrix: {\"include\":$matrix_include}"
          fi

  build-push:
    name: üèóÔ∏è Build ${{ matrix.image }} (${{ matrix.target || 'default' }})
    needs: detect-images
    if: needs.detect-images.outputs.matrix != '{\"include\":[]}'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    strategy:
      matrix: ${{ fromJSON(needs.detect-images.outputs.matrix) }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      - name: üîê Login to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Determine version for ${{ matrix.image }}
        id: version
        run: |
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/images/${{ matrix.image }}"

          # Determine build type and set tags
          if [ "${{ matrix.target }}" = "development-web" ]; then
            # Development web: use 'dev-web' tag
            echo "VERSION=dev-web" >> $GITHUB_OUTPUT
            echo "TAGS=${IMAGE_NAME}:dev-web" >> $GITHUB_OUTPUT
            echo "Development web build - using 'dev-web' tag"
          elif [ "${{ matrix.target }}" = "cli" ]; then
            # CLI: use 'cli' tag (same for dev and prod)
            echo "VERSION=cli" >> $GITHUB_OUTPUT
            echo "TAGS=${IMAGE_NAME}:cli" >> $GITHUB_OUTPUT
            echo "CLI build - using 'cli' tag"
          elif [ "${{ matrix.target }}" = "production-web" ]; then
            # Production web: use semantic versioning with -web suffix
            VARIANT_SUFFIX="-web"
            echo "Production web build"

            # Try to get the latest version from GHCR
            LATEST_TAG=$(docker manifest inspect ${IMAGE_NAME}:latest${VARIANT_SUFFIX} 2>/dev/null | \
              jq -r '.manifests[0].annotations."org.opencontainers.image.version"' 2>/dev/null || echo "")

            if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
              # No existing version, check git tags for this app
              LATEST_TAG=$(git tag -l "${{ matrix.image }}/v*" --sort=-v:refname | head -n1 | sed 's|${{ matrix.image }}/||' || echo "")
            fi

            if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
              # No version found, start with v0.1.0
              NEW_VERSION="v0.1.0"
              echo "No existing version found, starting with $NEW_VERSION"
            else
              # Bump version based on commits
              echo "Latest version: $LATEST_TAG"

              # Get commits since last tag for this app
              LAST_TAG_COMMIT=$(git rev-list -n 1 "${{ matrix.image }}/${LATEST_TAG}" 2>/dev/null || echo "")

              if [ -n "$LAST_TAG_COMMIT" ]; then
                COMMITS=$(git log ${LAST_TAG_COMMIT}..HEAD --oneline -- examples/${{ matrix.image }}/ | wc -l)
              else
                COMMITS=$(git log --oneline -- examples/${{ matrix.image }}/ | wc -l)
              fi

              if [ "$COMMITS" -eq 0 ]; then
                # No changes, keep same version
                NEW_VERSION="$LATEST_TAG"
                echo "No changes detected, keeping version $NEW_VERSION"
              else
                # Analyze commits for version bump type
                if git log ${LAST_TAG_COMMIT}..HEAD -- examples/${{ matrix.image }}/ | grep -qiE "^(feat|feature)(\(.*\))?!:|BREAKING CHANGE:"; then
                  # Breaking change -> major bump
                  BUMP_TYPE="major"
                elif git log ${LAST_TAG_COMMIT}..HEAD -- examples/${{ matrix.image }}/ | grep -qiE "^(feat|feature)(\(.*\))?:"; then
                  # New feature -> minor bump
                  BUMP_TYPE="minor"
                else
                  # Bug fix or other -> patch bump
                  BUMP_TYPE="patch"
                fi

                # Parse current version
                CURRENT_VERSION="${LATEST_TAG#v}"
                IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

                # Bump version
                case "$BUMP_TYPE" in
                  major)
                    MAJOR=$((MAJOR + 1))
                    MINOR=0
                    PATCH=0
                    ;;
                  minor)
                    MINOR=$((MINOR + 1))
                    PATCH=0
                    ;;
                  patch)
                    PATCH=$((PATCH + 1))
                    ;;
                esac

                NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
                echo "Bumped version: $LATEST_TAG -> $NEW_VERSION (type: $BUMP_TYPE, commits: $COMMITS)"
              fi
            fi

            echo "VERSION=${NEW_VERSION}${VARIANT_SUFFIX}" >> $GITHUB_OUTPUT
            echo "TAGS=${IMAGE_NAME}:${NEW_VERSION}${VARIANT_SUFFIX},${IMAGE_NAME}:latest${VARIANT_SUFFIX}" >> $GITHUB_OUTPUT
            echo "Production build - using version ${NEW_VERSION}${VARIANT_SUFFIX}"
          fi

      - name: üèóÔ∏è Build and push ${{ matrix.image }} (${{ matrix.target || 'default' }})
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: examples/${{ matrix.image }}
          target: ${{ matrix.target }}
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.version.outputs.TAGS }}
          labels: |
            org.opencontainers.image.title=${{ matrix.image }} Demo Application
            org.opencontainers.image.description=${{ matrix.image }} demo application - Production-ready Kubernetes deployment with Helm charts
            org.opencontainers.image.version=${{ steps.version.outputs.VERSION }}
            org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}/tree/main/examples/${{ matrix.image }}
            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/main/examples/${{ matrix.image }}/README.md
            org.opencontainers.image.licenses=MIT
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ‚úÖ Image built and pushed successfully
        run: |
          echo "Successfully built and pushed ${{ matrix.image }} image"
          echo "Target: ${{ matrix.target || 'default' }}"
          echo "Version: ${{ steps.version.outputs.VERSION }}"
          echo "Tags: ${{ steps.version.outputs.TAGS }}"
