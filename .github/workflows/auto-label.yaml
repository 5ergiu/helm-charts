name: ğŸ·ï¸ Auto Label Issues

on:
  issues:
    types: [opened, edited]
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  auto-label:
    name: Apply Labels
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Label based on issue form
        if: github.event_name == 'issues'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title || '';
            const labels = [];

            console.log('Processing issue form data...');
            
            // Parse structured issue form data
            // GitHub issue forms use this format: ### Field Label\n\nValue
            const parseFormField = (fieldLabel) => {
              const regex = new RegExp(`###\\s*${fieldLabel}\\s*\\n\\s*\\n([^#]+)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : null;
            };

            // Extract chart selection from dropdown (works for all issue types)
            const affectedChart = parseFormField('ğŸ“¦ Affected Chart|ğŸ“¦ Target Chart');
            console.log(`Detected chart: ${affectedChart}`);
            
            if (affectedChart) {
              if (affectedChart.includes('Laravel')) {
                labels.push('chart:laravel');
              }
              if (affectedChart.includes('Next.js')) {
                labels.push('chart:nextjs');
              }
              if (affectedChart.includes('Multiple charts')) {
                labels.push('multiple-charts');
              }
              if (affectedChart.includes('New chart')) {
                labels.push('new-chart');
              }
              if (affectedChart.includes('Repository infrastructure')) {
                labels.push('area:infrastructure');
              }
            }

            // Priority detection (from Feature Request priority dropdown)
            const priority = parseFormField('Priority');
            if (priority) {
              if (priority.includes('Critical')) {
                labels.push('priority:critical');
              } else if (priority.includes('Important')) {
                labels.push('priority:high');
              }
            }

            // Category detection from Question issue type
            const questionCategory = parseFormField('ğŸ·ï¸ Question Category');
            if (questionCategory) {
              if (questionCategory.includes('Installation')) {
                labels.push('area:installation');
              }
              if (questionCategory.includes('Configuration')) {
                labels.push('area:configuration');
              }
              if (questionCategory.includes('Troubleshooting')) {
                labels.push('help-wanted');
              }
              if (questionCategory.includes('Best practices')) {
                labels.push('discussion');
              }
              if (questionCategory.includes('Security')) {
                labels.push('security');
              }
              if (questionCategory.includes('Performance')) {
                labels.push('area:performance');
              }
              if (questionCategory.includes('Integration')) {
                labels.push('area:integration');
              }
            }

            // Documentation issue type detection
            const docType = parseFormField('ğŸ“„ Documentation Type');
            if (docType) {
              labels.push('documentation');
              if (docType.includes('values.yaml')) {
                labels.push('area:configuration');
              }
            }

            const docIssueType = parseFormField('ğŸ¯ Issue Type');
            if (docIssueType) {
              if (docIssueType.includes('Missing information')) {
                labels.push('enhancement');
              }
              if (docIssueType.includes('Incorrect')) {
                labels.push('bug');
              }
              if (docIssueType.includes('Broken link')) {
                labels.push('bug');
              }
            }

            // Chart version detection for bug reports
            const chartVersion = parseFormField('Chart Version');
            if (chartVersion && chartVersion !== 'N/A') {
              console.log(`Chart version: ${chartVersion}`);
            }

            // Security detection from body content
            if (body.toLowerCase().includes('security') || 
                body.toLowerCase().includes('vulnerability') ||
                body.toLowerCase().includes('cve')) {
              labels.push('security');
            }

            // Additional context-based labeling
            if (body.toLowerCase().includes('breaking change') || 
                body.toLowerCase().includes('backwards compatibility')) {
              labels.push('breaking-change');
            }

            if (body.toLowerCase().includes('urgent') || title.toLowerCase().includes('urgent')) {
              labels.push('priority:high');
            }

            // Test-related detection
            if (body.toLowerCase().includes('test') || 
                body.toLowerCase().includes('testing') ||
                body.toLowerCase().includes('helm unittest')) {
              labels.push('area:testing');
            }

            // CI/CD related
            if (body.toLowerCase().includes('workflow') || 
                body.toLowerCase().includes('github action') ||
                body.toLowerCase().includes('ci/cd')) {
              labels.push('area:ci-cd');
            }

            // Apply labels if any were found
            if (labels.length > 0) {
              // Remove duplicates
              const uniqueLabels = [...new Set(labels)];
              console.log(`Adding labels: ${uniqueLabels.join(', ')}`);
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: uniqueLabels
              });
            } else {
              console.log('No additional labels to add');
            }

      - name: Label PRs based on files changed
        if: github.event_name == 'pull_request'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const pr = context.payload.pull_request;
            const labels = [];

            // Get list of files changed in PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const changedFiles = files.map(f => f.filename);
            console.log('Changed files:', changedFiles);

            // Detect chart changes
            const chartChanges = new Set();
            for (const file of changedFiles) {
              if (file.startsWith('charts/')) {
                const parts = file.split('/');
                if (parts.length >= 2) {
                  chartChanges.add(parts[1]);
                }
              }
            }

            // Add chart-specific labels
            if (chartChanges.has('laravel')) labels.push('chart:laravel');
            if (chartChanges.has('nextjs')) labels.push('chart:nextjs');
            if (chartChanges.size > 1) labels.push('multiple-charts');

            // Detect change types
            const hasChartYaml = changedFiles.some(f => f.includes('Chart.yaml'));
            const hasValues = changedFiles.some(f => f.includes('values.yaml'));
            const hasTemplates = changedFiles.some(f => f.includes('/templates/'));
            const hasTests = changedFiles.some(f => f.includes('/tests/'));
            const hasDocs = changedFiles.some(f => f.endsWith('.md'));
            const hasWorkflows = changedFiles.some(f => f.startsWith('.github/workflows/'));
            const hasScripts = changedFiles.some(f => f.startsWith('scripts/'));

            // Area labels
            if (hasTemplates) labels.push('area:templates');
            if (hasValues) labels.push('area:configuration');
            if (hasTests) labels.push('area:testing');
            if (hasDocs) labels.push('documentation');
            if (hasWorkflows || hasScripts) labels.push('area:ci-cd');

            // Size labels based on changes
            const additions = pr.additions || 0;
            const deletions = pr.deletions || 0;
            const totalChanges = additions + deletions;

            if (totalChanges < 10) {
              labels.push('size:xs');
            } else if (totalChanges < 50) {
              labels.push('size:s');
            } else if (totalChanges < 200) {
              labels.push('size:m');
            } else if (totalChanges < 500) {
              labels.push('size:l');
            } else {
              labels.push('size:xl');
            }

            // Version bump detection
            if (hasChartYaml) {
              const chartYamlFiles = files.filter(f => f.filename.includes('Chart.yaml'));
              for (const file of chartYamlFiles) {
                if (file.patch && file.patch.includes('+version:')) {
                  labels.push('version-bump');
                  break;
                }
              }
            }

            // Check for breaking changes from PR title
            const title = pr.title.toLowerCase();
            if (title.includes('breaking') || title.includes('!:')) {
              labels.push('breaking-change');
            }

            // Apply labels
            if (labels.length > 0) {
              console.log(`Adding labels: ${labels.join(', ')}`);
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: labels
              });
            }

      - name: Add comment for first-time contributors
        if: github.event_name == 'pull_request'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const pr = context.payload.pull_request;
            
            // Check if this is the author's first PR
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              creator: pr.user.login
            });
            
            if (prs.length === 1) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `## ğŸ‘‹ Welcome @` + `${pr.user.login}!

Thank you for your first contribution to our Helm Charts repository! ğŸ‰

### What's Next?

1. âœ… Our CI/CD will automatically run tests on your changes
2. ğŸ‘€ A maintainer will review your PR shortly
3. ğŸ’¬ Feel free to ask questions or request help in the comments

### Helpful Resources

- ğŸ“š [Contributing Guide](../blob/main/CONTRIBUTING.md)
- ğŸ§ª [Testing Guide](../blob/main/TESTING.md)
- ğŸ” [Chart Signing](../blob/main/COSIGN.md)

We appreciate your contribution! ğŸš€`
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['first-time-contributor']
              });
            }
